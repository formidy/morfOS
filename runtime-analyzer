local CONFIG = {
    BLOCK_MALICIOUS_SCRIPTS = false,
    MONITOR_DURATION = 1000,
    AUTO_SAVE_LOGS = true,
    ROBUX_STEALER_THRESHOLD = 1,
    DATA_STEALER_THRESHOLD = 3,
    KEYLOGGER_THRESHOLD = 1,
    MONITOR_EXECUTOR_ONLY = true,
    IGNORE_GAME_SCRIPTS = true,
    SHOW_DETECTIONS = true,
    SHOW_ANALYSIS_DETAILS = true,
    MAX_REPORT_ACTIVITIES = 50,
    DEBUG_MODE = false,
    BLOCK_WEBHOOKS = true,
    BLOCK_PURCHASE_PROMPTS = true,
    BLOCK_TELEPORTS = false,
    BLOCK_KEYLOGGERS = true,
    HTTP_SPY_ENABLED = true,
    SHOW_ALL_HTTP_REQUESTS = true,
    LOG_HTTP_DATA = true,
    MAX_DATA_LOG_LENGTH = 1000,
    SHOW_PACKET_DETAILS = true,
    SHOW_HEX_DUMPS = true
}

local function SafeCall(func, description)
    if not func then 
        warn("[SAFE_CALL] No function provided for: " .. (description or "unknown"))
        return false, "No function provided"
    end
    
    local success, result = pcall(func)
    if not success then
        local errorMsg = "[SAFE_CALL ERROR] " .. (description or "unknown") .. ": " .. tostring(result)
        if CONFIG.DEBUG_MODE then
            warn(errorMsg)
        end
        return false, result
    end
    return true, result
end

local function SafeGetService(serviceName)
    if not serviceName or type(serviceName) ~= "string" then
        warn("[SAFE_GET_SERVICE] Invalid service name: " .. tostring(serviceName))
        return nil
    end
    
    local success, service = SafeCall(function()
        return game:GetService(serviceName)
    end, "Getting service: " .. serviceName)
    
    if not success then
        warn("[SAFE_GET_SERVICE] Failed to get service: " .. serviceName .. " - " .. tostring(service))
        return nil
    end
    
    return service
end

local function debugPrint(message, level)
    if not CONFIG.DEBUG_MODE then return end
    
    level = level or "INFO"
    local timestamp = SafeCall(function() return string.format("%.2f", tick()) end, "Getting timestamp")
    local timeStr = (timestamp and timestamp[2]) and timestamp[2] or "?.??"
    
    print("[DEBUG/" .. level .. "][" .. timeStr .. "s] " .. tostring(message))
end

local function SafeJSONEncode(data)
    local HttpService = SafeGetService("HttpService")
    if not HttpService then
        return tostring(data or "nil")
    end
    
    local success, result = SafeCall(function()
        return HttpService:JSONEncode(data or {})
    end, "JSON encoding")
    
    return success and result or tostring(data or "nil")
end

local function TruncateData(data, maxLength)
    if not data then return "nil" end
    local dataStr = tostring(data)
    if #dataStr > maxLength then
        return string.sub(dataStr, 1, maxLength) .. "... [TRUNCATED " .. (#dataStr - maxLength) .. " chars]"
    end
    return dataStr
end

local function ToHex(data, maxBytes)
    if not data then return "nil" end
    local dataStr = tostring(data)
    local hex = ""
    local limit = math.min(#dataStr, maxBytes or 200)
    
    for i = 1, limit do
        hex = hex .. string.format("%02X ", string.byte(dataStr, i))
        if i % 16 == 0 then
            hex = hex .. "\n"
        end
    end
    
    if #dataStr > limit then
        hex = hex .. "\n[... " .. (#dataStr - limit) .. " more bytes]"
    end
    
    return hex
end

local ScriptTester = {}
local Players = SafeGetService("Players")
local RunService = SafeGetService("RunService")
local HttpService = SafeGetService("HttpService")
local MarketplaceService = SafeGetService("MarketplaceService")
local TeleportService = SafeGetService("TeleportService")
local UserInputService = SafeGetService("UserInputService")
local CoreGui = SafeGetService("CoreGui")
local TweenService = SafeGetService("TweenService")

local LocalPlayer = nil
SafeCall(function()
    if Players then
        LocalPlayer = Players.LocalPlayer
    end
end, "Getting LocalPlayer")

local MonitoringActive = false
local StartTime = 0

local ActivityLog = {}
local MaliciousActivities = {}
local NetworkRequests = {}
local FileOperations = {}
local KeystrokeLog = {}
local ChatInterceptions = {}
local ServiceAccess = {}
local OriginalFunctions = {}
local HookedFunctions = {}
local PurchaseAttempts = {}
local DataCollectionPatterns = {}
local BlockedScripts = {}
local HTTPSpyLog = {}
local HTTPRequestCounter = 0

local UI = {}
UI.ScreenGui = nil
UI.MainFrame = nil
UI.RequestsList = nil
UI.StatusLabel = nil

local function CreateUI()
    SafeCall(function()
        if UI.ScreenGui then
            UI.ScreenGui:Destroy()
        end
        
        UI.ScreenGui = Instance.new("ScreenGui")
        UI.ScreenGui.Name = "RuntimeAnalyzerGUI"
        UI.ScreenGui.ResetOnSpawn = false
        UI.ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
        
        if gethui then
            UI.ScreenGui.Parent = gethui()
        elseif syn and syn.protect_gui then
            syn.protect_gui(UI.ScreenGui)
            UI.ScreenGui.Parent = CoreGui
        else
            UI.ScreenGui.Parent = CoreGui
        end
        
        UI.MainFrame = Instance.new("Frame")
        UI.MainFrame.Name = "MainFrame"
        UI.MainFrame.Parent = UI.ScreenGui
        UI.MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        UI.MainFrame.BorderSizePixel = 0
        UI.MainFrame.Position = UDim2.new(0, 50, 0, 50)
        UI.MainFrame.Size = UDim2.new(0, 900, 0, 600)
        UI.MainFrame.Active = true
        UI.MainFrame.Draggable = true
        
        local Corner = Instance.new("UICorner")
        Corner.CornerRadius = UDim.new(0, 8)
        Corner.Parent = UI.MainFrame
        
        local Shadow = Instance.new("Frame")
        Shadow.Name = "Shadow"
        Shadow.Parent = UI.MainFrame
        Shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        Shadow.BackgroundTransparency = 0.7
        Shadow.BorderSizePixel = 0
        Shadow.Position = UDim2.new(0, 4, 0, 4)
        Shadow.Size = UDim2.new(1, 0, 1, 0)
        Shadow.ZIndex = -1
        
        local ShadowCorner = Instance.new("UICorner")
        ShadowCorner.CornerRadius = UDim.new(0, 8)
        ShadowCorner.Parent = Shadow
        
        local TitleBar = Instance.new("Frame")
        TitleBar.Name = "TitleBar"
        TitleBar.Parent = UI.MainFrame
        TitleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        TitleBar.BorderSizePixel = 0
        TitleBar.Size = UDim2.new(1, 0, 0, 40)
        
        local TitleCorner = Instance.new("UICorner")
        TitleCorner.CornerRadius = UDim.new(0, 8)
        TitleCorner.Parent = TitleBar
        
        local TitleFix = Instance.new("Frame")
        TitleFix.Parent = TitleBar
        TitleFix.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        TitleFix.BorderSizePixel = 0
        TitleFix.Position = UDim2.new(0, 0, 0.5, 0)
        TitleFix.Size = UDim2.new(1, 0, 0.5, 0)
        
        local TitleLabel = Instance.new("TextLabel")
        TitleLabel.Name = "TitleLabel"
        TitleLabel.Parent = TitleBar
        TitleLabel.BackgroundTransparency = 1
        TitleLabel.Position = UDim2.new(0, 15, 0, 0)
        TitleLabel.Size = UDim2.new(1, -15, 1, 0)
        TitleLabel.Font = Enum.Font.RobotoMono
        TitleLabel.Text = "RUNTIME ANALYZER v2.2 - HTTP SPY"
        TitleLabel.TextColor3 = Color3.fromRGB(0, 255, 127)
        TitleLabel.TextSize = 16
        TitleLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        local CloseButton = Instance.new("TextButton")
        CloseButton.Name = "CloseButton"
        CloseButton.Parent = TitleBar
        CloseButton.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
        CloseButton.BorderSizePixel = 0
        CloseButton.Position = UDim2.new(1, -35, 0, 5)
        CloseButton.Size = UDim2.new(0, 30, 0, 30)
        CloseButton.Font = Enum.Font.RobotoMono
        CloseButton.Text = "×"
        CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        CloseButton.TextSize = 18
        
        local CloseCorner = Instance.new("UICorner")
        CloseCorner.CornerRadius = UDim.new(0, 4)
        CloseCorner.Parent = CloseButton
        
        local StatusFrame = Instance.new("Frame")
        StatusFrame.Name = "StatusFrame"
        StatusFrame.Parent = UI.MainFrame
        StatusFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        StatusFrame.BorderSizePixel = 0
        StatusFrame.Position = UDim2.new(0, 10, 0, 50)
        StatusFrame.Size = UDim2.new(1, -20, 0, 80)
        
        local StatusCorner = Instance.new("UICorner")
        StatusCorner.CornerRadius = UDim.new(0, 6)
        StatusCorner.Parent = StatusFrame
        
        UI.StatusLabel = Instance.new("TextLabel")
        UI.StatusLabel.Name = "StatusLabel"
        UI.StatusLabel.Parent = StatusFrame
        UI.StatusLabel.BackgroundTransparency = 1
        UI.StatusLabel.Position = UDim2.new(0, 15, 0, 10)
        UI.StatusLabel.Size = UDim2.new(1, -30, 0, 25)
        UI.StatusLabel.Font = Enum.Font.RobotoMono
        UI.StatusLabel.Text = "STATUS: MONITORING ACTIVE"
        UI.StatusLabel.TextColor3 = Color3.fromRGB(0, 255, 127)
        UI.StatusLabel.TextSize = 14
        UI.StatusLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        local RequestsLabel = Instance.new("TextLabel")
        RequestsLabel.Name = "RequestsLabel"
        RequestsLabel.Parent = StatusFrame
        RequestsLabel.BackgroundTransparency = 1
        RequestsLabel.Position = UDim2.new(0, 15, 0, 35)
        RequestsLabel.Size = UDim2.new(1, -30, 0, 20)
        RequestsLabel.Font = Enum.Font.RobotoMono
        RequestsLabel.Text = "HTTP REQUESTS: 0 | DETECTIONS: 0"
        RequestsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        RequestsLabel.TextSize = 12
        RequestsLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        local StopButton = Instance.new("TextButton")
        StopButton.Name = "StopButton"
        StopButton.Parent = StatusFrame
        StopButton.BackgroundColor3 = Color3.fromRGB(255, 85, 85)
        StopButton.BorderSizePixel = 0
        StopButton.Position = UDim2.new(1, -100, 0, 10)
        StopButton.Size = UDim2.new(0, 85, 0, 30)
        StopButton.Font = Enum.Font.RobotoMono
        StopButton.Text = "STOP"
        StopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        StopButton.TextSize = 14
        
        local StopCorner = Instance.new("UICorner")
        StopCorner.CornerRadius = UDim.new(0, 4)
        StopCorner.Parent = StopButton
        
        local ClearButton = Instance.new("TextButton")
        ClearButton.Name = "ClearButton"
        ClearButton.Parent = StatusFrame
        ClearButton.BackgroundColor3 = Color3.fromRGB(85, 170, 255)
        ClearButton.BorderSizePixel = 0
        ClearButton.Position = UDim2.new(1, -200, 0, 10)
        ClearButton.Size = UDim2.new(0, 85, 0, 30)
        ClearButton.Font = Enum.Font.RobotoMono
        ClearButton.Text = "CLEAR"
        ClearButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        ClearButton.TextSize = 14
        
        local ClearCorner = Instance.new("UICorner")
        ClearCorner.CornerRadius = UDim.new(0, 4)
        ClearCorner.Parent = ClearButton
        
        local RequestsFrame = Instance.new("Frame")
        RequestsFrame.Name = "RequestsFrame"
        RequestsFrame.Parent = UI.MainFrame
        RequestsFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        RequestsFrame.BorderSizePixel = 0
        RequestsFrame.Position = UDim2.new(0, 10, 0, 140)
        RequestsFrame.Size = UDim2.new(1, -20, 1, -150)
        
        local RequestsCorner = Instance.new("UICorner")
        RequestsCorner.CornerRadius = UDim.new(0, 6)
        RequestsCorner.Parent = RequestsFrame
        
        local RequestsTitle = Instance.new("TextLabel")
        RequestsTitle.Name = "RequestsTitle"
        RequestsTitle.Parent = RequestsFrame
        RequestsTitle.BackgroundTransparency = 1
        RequestsTitle.Position = UDim2.new(0, 15, 0, 10)
        RequestsTitle.Size = UDim2.new(1, -30, 0, 25)
        RequestsTitle.Font = Enum.Font.RobotoMono
        RequestsTitle.Text = "HTTP REQUESTS LOG"
        RequestsTitle.TextColor3 = Color3.fromRGB(0, 255, 127)
        RequestsTitle.TextSize = 14
        RequestsTitle.TextXAlignment = Enum.TextXAlignment.Left
        
        UI.RequestsList = Instance.new("ScrollingFrame")
        UI.RequestsList.Name = "RequestsList"
        UI.RequestsList.Parent = RequestsFrame
        UI.RequestsList.BackgroundColor3 = Color3.fromRGB(15, 15, 15)
        UI.RequestsList.BorderSizePixel = 0
        UI.RequestsList.Position = UDim2.new(0, 10, 0, 40)
        UI.RequestsList.Size = UDim2.new(1, -20, 1, -50)
        UI.RequestsList.ScrollBarThickness = 8
        UI.RequestsList.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
        UI.RequestsList.CanvasSize = UDim2.new(0, 0, 0, 0)
        
        local ListCorner = Instance.new("UICorner")
        ListCorner.CornerRadius = UDim.new(0, 4)
        ListCorner.Parent = UI.RequestsList
        
        local UIListLayout = Instance.new("UIListLayout")
        UIListLayout.Parent = UI.RequestsList
        UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        UIListLayout.Padding = UDim.new(0, 5)
        
        CloseButton.MouseButton1Click:Connect(function()
            UI.ScreenGui:Destroy()
        end)
        
        StopButton.MouseButton1Click:Connect(function()
            MonitoringActive = false
            UI.StatusLabel.Text = "STATUS: MONITORING STOPPED"
            UI.StatusLabel.TextColor3 = Color3.fromRGB(255, 85, 85)
            StopButton.Text = "STOPPED"
            StopButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        end)
        
        ClearButton.MouseButton1Click:Connect(function()
            for _, child in pairs(UI.RequestsList:GetChildren()) do
                if child:IsA("Frame") then
                    child:Destroy()
                end
            end
            UI.RequestsList.CanvasSize = UDim2.new(0, 0, 0, 0)
        end)
        
        spawn(function()
            while UI.ScreenGui.Parent do
                wait(1)
                if UI.StatusLabel then
                    local requestCount = #HTTPSpyLog
                    local detectionCount = #MaliciousActivities
                    RequestsLabel.Text = "HTTP REQUESTS: " .. requestCount .. " | DETECTIONS: " .. detectionCount
                end
            end
        end)
        
    end, "Creating UI")
end

local function FormatRequestAsPython(httpData)
    local headers = {}
    for k, v in pairs(httpData.request_headers or {}) do
        table.insert(headers, string.format("    '%s': '%s'", k, v))
    end
    local headersStr = "{\n" .. table.concat(headers, ",\n") .. "\n}"
    
    local dataStr = "None"
    if httpData.request_data_raw and httpData.request_data_raw ~= "[LOGGING_DISABLED]" then
        if httpData.contains_json then
            dataStr = httpData.request_data_raw
        else
            dataStr = "'" .. httpData.request_data_raw:gsub("'", "\\'") .. "'"
        end
    end
    
    return string.format(
        "import requests\n\nurl = '%s'\nheaders = %s\ndata = %s\n\nresponse = requests.%s(url, headers=headers%s)\nprint(response.text)",
        httpData.url,
        headersStr,
        dataStr,
        httpData.method:lower(),
        dataStr ~= "None" and ", data=data" or ""
    )
end

local function FormatRequestAsCurl(httpData)
    local cmd = "curl -X " .. httpData.method
    
    for k, v in pairs(httpData.request_headers or {}) do
        cmd = cmd .. string.format(" -H '%s: %s'", k, v)
    end
    
    if httpData.request_data_raw and httpData.request_data_raw ~= "[LOGGING_DISABLED]" then
        cmd = cmd .. " -d '" .. httpData.request_data_raw:gsub("'", "\\'") .. "'"
    end
    
    cmd = cmd .. " '" .. httpData.url .. "'"
    
    return cmd
end

local function FormatRequestAsLua(httpData)
    local headersStr = "{"
    for k, v in pairs(httpData.request_headers or {}) do
        headersStr = headersStr .. string.format('\n    ["%s"] = "%s",', k, v)
    end
    headersStr = headersStr .. "\n}"
    
    local requestStr = string.format(
        'local HttpService = game:GetService("HttpService")\n\nlocal requestData = {\n    Url = "%s",\n    Method = "%s",\n    Headers = %s',
        httpData.url,
        httpData.method,
        headersStr
    )
    
    if httpData.request_data_raw and httpData.request_data_raw ~= "[LOGGING_DISABLED]" then
        requestStr = requestStr .. ',\n    Body = "' .. httpData.request_data_raw:gsub('"', '\\"') .. '"'
    end
    
    requestStr = requestStr .. "\n}\n\nlocal response = HttpService:RequestAsync(requestData)\nprint(response.Body)"
    
    return requestStr
end

local function FormatRequestAsJavaScript(httpData)
    local headersStr = "{"
    for k, v in pairs(httpData.request_headers or {}) do
        headersStr = headersStr .. string.format('\n    "%s": "%s",', k, v)
    end
    headersStr = headersStr .. "\n}"
    
    local bodyStr = "null"
    if httpData.request_data_raw and httpData.request_data_raw ~= "[LOGGING_DISABLED]" then
        bodyStr = "'" .. httpData.request_data_raw:gsub("'", "\\'") .. "'"
    end
    
    return string.format(
        'fetch("%s", {\n    method: "%s",\n    headers: %s,\n    body: %s\n})\n.then(response => response.text())\n.then(data => console.log(data));',
        httpData.url,
        httpData.method,
        headersStr,
        bodyStr
    )
end

local function CopyToClipboard(text)
    if setclipboard then
        setclipboard(text)
        return true
    elseif toclipboard then
        toclipboard(text)
        return true
    end
    return false
end

local function AddRequestToUI(httpData)
    SafeCall(function()
        if not UI.RequestsList or httpData.direction ~= "OUTGOING" then
            return
        end
        
        local RequestFrame = Instance.new("Frame")
        RequestFrame.Name = "Request_" .. (httpData.id or "unknown")
        RequestFrame.Parent = UI.RequestsList
        RequestFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
        RequestFrame.BorderSizePixel = 0
        RequestFrame.Size = UDim2.new(1, -10, 0, 120)
        RequestFrame.LayoutOrder = -(httpData.id or 0)
        
        local RequestCorner = Instance.new("UICorner")
        RequestCorner.CornerRadius = UDim.new(0, 4)
        RequestCorner.Parent = RequestFrame
        
        local MethodLabel = Instance.new("TextLabel")
        MethodLabel.Parent = RequestFrame
        MethodLabel.BackgroundTransparency = 1
        MethodLabel.Position = UDim2.new(0, 10, 0, 5)
        MethodLabel.Size = UDim2.new(0, 80, 0, 20)
        MethodLabel.Font = Enum.Font.RobotoMono
        MethodLabel.Text = httpData.method
        MethodLabel.TextColor3 = httpData.method == "POST" and Color3.fromRGB(255, 170, 85) or Color3.fromRGB(85, 170, 255)
        MethodLabel.TextSize = 12
        MethodLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        local UrlLabel = Instance.new("TextLabel")
        UrlLabel.Parent = RequestFrame
        UrlLabel.BackgroundTransparency = 1
        UrlLabel.Position = UDim2.new(0, 100, 0, 5)
        UrlLabel.Size = UDim2.new(1, -110, 0, 20)
        UrlLabel.Font = Enum.Font.RobotoMono
        UrlLabel.Text = TruncateData(httpData.url, 60)
        UrlLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        UrlLabel.TextSize = 12
        UrlLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        local SizeLabel = Instance.new("TextLabel")
        SizeLabel.Parent = RequestFrame
        SizeLabel.BackgroundTransparency = 1
        SizeLabel.Position = UDim2.new(0, 10, 0, 25)
        SizeLabel.Size = UDim2.new(0, 200, 0, 15)
        SizeLabel.Font = Enum.Font.RobotoMono
        SizeLabel.Text = string.format("SIZE: %db | TIME: %.3fs", httpData.request_size or 0, httpData.timing and httpData.timing.duration or 0)
        SizeLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        SizeLabel.TextSize = 10
        SizeLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        local SecurityLabel = Instance.new("TextLabel")
        SecurityLabel.Parent = RequestFrame
        SecurityLabel.BackgroundTransparency = 1
        SecurityLabel.Position = UDim2.new(0, 10, 0, 40)
        SecurityLabel.Size = UDim2.new(1, -20, 0, 15)
        SecurityLabel.Font = Enum.Font.RobotoMono
        SecurityLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        SecurityLabel.TextSize = 10
        SecurityLabel.TextXAlignment = Enum.TextXAlignment.Left
        
        local securityFlags = {}
        if httpData.is_webhook then table.insert(securityFlags, "WEBHOOK") end
        if httpData.is_suspicious_domain then table.insert(securityFlags, "SUSPICIOUS") end
        if httpData.contains_json then table.insert(securityFlags, "JSON") end
        if httpData.contains_base64 then table.insert(securityFlags, "BASE64") end
        SecurityLabel.Text = "FLAGS: " .. (next(securityFlags) and table.concat(securityFlags, " | ") or "NONE")
        
        local ButtonFrame = Instance.new("Frame")
        ButtonFrame.Parent = RequestFrame
        ButtonFrame.BackgroundTransparency = 1
        ButtonFrame.Position = UDim2.new(0, 10, 0, 60)
        ButtonFrame.Size = UDim2.new(1, -20, 0, 50)
        
        local buttons = {
            {text = "PYTHON", color = Color3.fromRGB(85, 170, 255), formatter = FormatRequestAsPython},
            {text = "CURL", color = Color3.fromRGB(255, 170, 85), formatter = FormatRequestAsCurl},
            {text = "LUA", color = Color3.fromRGB(170, 85, 255), formatter = FormatRequestAsLua},
            {text = "JS", color = Color3.fromRGB(255, 85, 170), formatter = FormatRequestAsJavaScript}
        }
        
        for i, buttonData in ipairs(buttons) do
            local CopyButton = Instance.new("TextButton")
            CopyButton.Parent = ButtonFrame
            CopyButton.BackgroundColor3 = buttonData.color
            CopyButton.BorderSizePixel = 0
            CopyButton.Position = UDim2.new(0, (i-1) * 70, 0, 0)
            CopyButton.Size = UDim2.new(0, 65, 0, 25)
            CopyButton.Font = Enum.Font.RobotoMono
            CopyButton.Text = buttonData.text
            CopyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            CopyButton.TextSize = 10
            
            local ButtonCorner = Instance.new("UICorner")
            ButtonCorner.CornerRadius = UDim.new(0, 3)
            ButtonCorner.Parent = CopyButton
            
            CopyButton.MouseButton1Click:Connect(function()
                local formatted = buttonData.formatter(httpData)
                local success = CopyToClipboard(formatted)
                
                CopyButton.Text = success and "COPIED!" or "NO CLIP"
                CopyButton.BackgroundColor3 = success and Color3.fromRGB(85, 255, 85) or Color3.fromRGB(255, 85, 85)
                
                wait(1)
                CopyButton.Text = buttonData.text
                CopyButton.BackgroundColor3 = buttonData.color
            end)
        end
        
        local RawButton = Instance.new("TextButton")
        RawButton.Parent = ButtonFrame
        RawButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        RawButton.BorderSizePixel = 0
        RawButton.Position = UDim2.new(0, 280, 0, 0)
        RawButton.Size = UDim2.new(0, 65, 0, 25)
        RawButton.Font = Enum.Font.RobotoMono
        RawButton.Text = "RAW"
        RawButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        RawButton.TextSize = 10
        
        local RawCorner = Instance.new("UICorner")
        RawCorner.CornerRadius = UDim.new(0, 3)
        RawCorner.Parent = RawButton
        
        RawButton.MouseButton1Click:Connect(function()
            local rawData = SafeJSONEncode(httpData)
            local success = CopyToClipboard(rawData)
            
            RawButton.Text = success and "COPIED!" or "NO CLIP"
            RawButton.BackgroundColor3 = success and Color3.fromRGB(85, 255, 85) or Color3.fromRGB(255, 85, 85)
            
            wait(1)
            RawButton.Text = "RAW"
            RawButton.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
        end)
        
        UI.RequestsList.CanvasSize = UDim2.new(0, 0, 0, UI.RequestsList.UIListLayout.AbsoluteContentSize.Y + 10)
        
    end, "Adding request to UI")
end

local function IsExecutorScript()
    if not CONFIG.MONITOR_EXECUTOR_ONLY then
        return true
    end
    
    local success, callingScript = SafeCall(function()
        return getcallingscript and getcallingscript() or nil
    end, "Getting calling script")
    
    if not success or not callingScript then
        debugPrint("Could not determine calling script, assuming executor", "WARN")
        return true
    end
    
    local scriptSource = tostring(callingScript)
    local gameScriptPatterns = {
        "ServerScriptService", "StarterPlayerScripts", "StarterGuiScripts", 
        "ReplicatedFirst", "ReplicatedStorage", "Workspace"
    }
    
    if CONFIG.IGNORE_GAME_SCRIPTS then
        for _, pattern in pairs(gameScriptPatterns) do
            if scriptSource:find(pattern) then
                debugPrint("Ignoring game script: " .. scriptSource, "INFO")
                return false
            end
        end
    end
    
    debugPrint("Monitoring executor script: " .. scriptSource, "INFO")
    return true
end

local function ShouldBlockActivity(activityType, severity)
    if not CONFIG.BLOCK_MALICIOUS_SCRIPTS then
        return false
    end
    
    if activityType:find("WEBHOOK") and CONFIG.BLOCK_WEBHOOKS then
        return true
    elseif activityType:find("PURCHASE") and CONFIG.BLOCK_PURCHASE_PROMPTS then
        return true
    elseif activityType:find("TELEPORT") and CONFIG.BLOCK_TELEPORTS then
        return true
    elseif activityType:find("KEYLOGGER") and CONFIG.BLOCK_KEYLOGGERS then
        return true
    end
    
    return severity >= 9
end

local function LogHTTPRequest(direction, method, url, requestData, responseData, headers, source, requestId, args, responseCode, responseHeaders, timing)
    SafeCall(function()
        if not MonitoringActive or not CONFIG.HTTP_SPY_ENABLED then 
            return 
        end
        
        local success, callingScript = SafeCall(function()
            return getcallingscript and getcallingscript() or "Unknown"
        end, "Getting calling script for HTTP spy")
        
        local scriptStr = success and tostring(callingScript) or "Unknown"
        
        local requestSize = 0
        local responseSize = 0
        local requestDataHex = nil
        local responseDataHex = nil
        
        if requestData then
            requestSize = #tostring(requestData)
            if CONFIG.LOG_HTTP_DATA and CONFIG.SHOW_HEX_DUMPS then
                requestDataHex = ToHex(requestData, 500)
            end
        end
        
        if responseData then
            responseSize = #tostring(responseData)
            if CONFIG.LOG_HTTP_DATA and CONFIG.SHOW_HEX_DUMPS then
                responseDataHex = ToHex(responseData, 500)
            end
        end
        
        local urlParts = {}
        SafeCall(function()
            local urlStr = tostring(url)
            urlParts.full_url = urlStr
            urlParts.protocol = urlStr:match("^([^:]+)://") or "unknown"
            urlParts.domain = urlStr:match("://([^/]+)") or "unknown"
            urlParts.path = urlStr:match("://[^/]+(.*)") or "/"
            urlParts.port = urlStr:match(":(%d+)") or (urlParts.protocol == "https" and "443" or "80")
        end, "Parsing URL components")
        
        local httpData = {
            id = requestId or HTTPRequestCounter,
            method = method,
            url = url,
            url_components = urlParts,
            request_data_raw = CONFIG.LOG_HTTP_DATA and TruncateData(requestData, CONFIG.MAX_DATA_LOG_LENGTH) or "[LOGGING_DISABLED]",
            response_data_raw = CONFIG.LOG_HTTP_DATA and TruncateData(responseData, CONFIG.MAX_DATA_LOG_LENGTH) or "[LOGGING_DISABLED]",
            request_data_hex = requestDataHex,
            response_data_hex = responseDataHex,
            request_headers = headers or {},
            response_headers = responseHeaders or {},
            headers_count = headers and (function() local c = 0; for _ in pairs(headers) do c = c + 1 end; return c end)() or 0,
            function_arguments = args and SafeCall(function()
                local argDetails = {}
                for i, arg in pairs(args) do
                    argDetails[i] = {
                        type = type(arg),
                        value = TruncateData(tostring(arg), 200),
                        size = #tostring(arg)
                    }
                end
                return argDetails
            end, "Processing function arguments") or {},
            source = source,
            timestamp = tick() - StartTime,
            script = scriptStr,
            direction = direction,
            request_size = requestSize,
            response_size = responseSize,
            response_code = responseCode,
            timing = timing or {
                start_time = tick(),
                end_time = tick(),
                duration = 0
            },
            content_type = headers and (headers["Content-Type"] or headers["content-type"]) or "unknown",
            user_agent = headers and (headers["User-Agent"] or headers["user-agent"]) or "unknown",
            is_webhook = tostring(url):lower():find("webhook") and true or false,
            is_discord = tostring(url):lower():find("discord") and true or false,
            is_suspicious_domain = false,
            contains_json = (requestData and tostring(requestData):find("[{%[]")) and true or false,
            contains_base64 = (requestData and tostring(requestData):match("[A-Za-z0-9+/]+=*$")) and true or false,
            contains_urls = (requestData and tostring(requestData):find("http")) and true or false
        }
        
        SafeCall(function()
            local suspiciousDomains = {
                "paste%.ee", "pastebin%.com", "hastebin%.com", "0x0%.st", "file%.io",
                "anonfiles%.com", "mega%.nz", "t%.me", "api%.telegram%.org"
            }
            for _, domain in pairs(suspiciousDomains) do
                if tostring(url):lower():find(domain) then
                    httpData.is_suspicious_domain = true
                    httpData.suspicious_domain_pattern = domain
                    break
                end
            end
        end, "Checking suspicious domains")
        
        table.insert(HTTPSpyLog, httpData)
        
        if direction == "OUTGOING" then
            AddRequestToUI(httpData)
        end
        
        if CONFIG.SHOW_ALL_HTTP_REQUESTS then
            local urlStr = tostring(url)
            if #urlStr > 60 then
                urlStr = string.sub(urlStr, 1, 60) .. "..."
            end
            
            local dataInfo = ""
            local securityFlags = ""
            
            if requestData and direction == "OUTGOING" then
                dataInfo = " [REQ:" .. requestSize .. "b"
                if httpData.contains_json then dataInfo = dataInfo .. ",JSON" end
                if httpData.contains_base64 then dataInfo = dataInfo .. ",B64" end
                dataInfo = dataInfo .. "]"
            elseif responseData and direction == "INCOMING" then
                dataInfo = " [RESP:" .. responseSize .. "b"
                if responseCode then dataInfo = dataInfo .. ",CODE:" .. responseCode end
                dataInfo = dataInfo .. "]"
            end
            
            if httpData.is_webhook then securityFlags = securityFlags .. "[WEBHOOK]" end
            if httpData.is_suspicious_domain then securityFlags = securityFlags .. "[SUSPICIOUS]" end
            
            print("╔══════════════════════════════════════════════════════════════════════════════╗")
            print("║ [HTTP-SPY] [" .. direction .. "] " .. method .. " -> " .. tostring(url))
            print("╠──────────────────────────────────────────────────────────────────────────────╢")
            print("║ Request ID: " .. (httpData.id or "UNKNOWN"))
            print("║ Source: " .. (httpData.source or "Unknown"))
            print("║ Script: " .. scriptStr)
            print("║ Domain: " .. urlParts.domain)
            print("║ Protocol: " .. urlParts.protocol .. " | Port: " .. urlParts.port)
            print("║ Path: " .. urlParts.path)
            
            if direction == "OUTGOING" then
                print("║ ")
                print("║ ┌─ OUTGOING REQUEST DATA ─────────────────────────────────────────────────")
                if args and #args > 0 then
                    print("║ │ Function Arguments (" .. #args .. "):")
                    for i, arg in pairs(args) do
                        local argStr = TruncateData(tostring(arg), 80)
                        print("║ │   [" .. i .. "] " .. type(arg) .. ": " .. argStr)
                    end
                end
                
                if headers and next(headers) then
                    print("║ │ Request Headers (" .. httpData.headers_count .. "):")
                    for k, v in pairs(headers) do
                        print("║ │   " .. tostring(k) .. ": " .. tostring(v))
                    end
                end
                
                if requestData then
                    print("║ │ Request Body (" .. requestSize .. " bytes):")
                    local truncated = TruncateData(requestData, 200)
                    print("║ │   " .. truncated)
                    
                    if CONFIG.SHOW_HEX_DUMPS and requestDataHex then
                        print("║ │ Hex Dump:")
                        for line in requestDataHex:gmatch("[^\r\n]+") do
                            print("║ │   " .. line)
                        end
                    end
                end
                print("║ └─────────────────────────────────────────────────────────────────────────")
            else
                print("║ ")
                print("║ ┌─ INCOMING RESPONSE DATA ────────────────────────────────────────────────")
                if responseCode then
                    print("║ │ Response Code: " .. responseCode)
                end
                
                if responseHeaders and next(responseHeaders) then
                    print("║ │ Response Headers:")
                    for k, v in pairs(responseHeaders) do
                        print("║ │   " .. tostring(k) .. ": " .. tostring(v))
                    end
                end
                
                if responseData then
                    print("║ │ Response Body (" .. responseSize .. " bytes):")
                    local truncated = TruncateData(responseData, 200)
                    print("║ │   " .. truncated)
                    
                    if CONFIG.SHOW_HEX_DUMPS and responseDataHex then
                        print("║ │ Hex Dump:")
                        for line in responseDataHex:gmatch("[^\r\n]+") do
                            print("║ │   " .. line)
                        end
                    end
                end
                
                if timing and timing.duration then
                    print("║ │ Request Duration: " .. string.format("%.3f", timing.duration) .. "s")
                end
                print("║ └─────────────────────────────────────────────────────────────────────────")
            end
            
            if securityFlags ~= "" then
                print("║ ⚠️  SECURITY FLAGS: " .. securityFlags)
            end
            print("╚══════════════════════════════════════════════════════════════════════════════╝")
            print("")
        end
        
        debugPrint("HTTP " .. direction .. " logged: " .. method .. " to " .. tostring(url) .. " (" .. (requestSize + responseSize) .. " bytes total)", "INFO")
    end, "HTTP request logging")
end

local function LogActivity(activityType, details, severity)
    SafeCall(function()
        if not MonitoringActive or not IsExecutorScript() then 
            return 
        end
        
        local success, callingScript = SafeCall(function()
            return getcallingscript and getcallingscript() or "Unknown"
        end, "Getting calling script for logging")
        
        local scriptStr = success and tostring(callingScript) or "Unknown"
        
        local activity = {
            type = activityType,
            details = details,
            severity = severity,
            timestamp = tick() - StartTime,
            script = scriptStr,
            stack = SafeCall(function() return debug.traceback() end, "Getting stack trace") and debug.traceback() or "No stack"
        }
        
        table.insert(ActivityLog, activity)
        debugPrint("Activity logged: " .. activityType .. " (severity: " .. severity .. ")", "INFO")
    end, "Activity logging")
end

local function AddMaliciousActivity(activityType, data, severity)
    SafeCall(function()
        if not MonitoringActive or not IsExecutorScript() then 
            return 
        end
        
        local success, callingScript = SafeCall(function()
            return getcallingscript and getcallingscript() or "Unknown"
        end, "Getting calling script for malicious activity")
        
        local scriptStr = success and tostring(callingScript) or "Unknown"
        
        local activity = {
            type = activityType,
            data = data,
            severity = severity,
            timestamp = tick() - StartTime,
            script = scriptStr,
            stack = SafeCall(function() return debug.traceback() end, "Getting stack trace") and debug.traceback() or "No stack"
        }
        
        table.insert(MaliciousActivities, activity)
        
        if CONFIG.SHOW_DETECTIONS then
            local jsonData = SafeJSONEncode(data or {})
            warn("[DETECTION] " .. activityType .. ": " .. jsonData)
        end
        
        debugPrint("Malicious activity detected: " .. activityType .. " (severity: " .. severity .. ")", "WARN")
        
        if ShouldBlockActivity(activityType, severity) then
            local scriptId = scriptStr
            if not BlockedScripts[scriptId] then
                BlockedScripts[scriptId] = {
                    script = callingScript,
                    reason = activityType,
                    timestamp = tick() - StartTime
                }
                warn("[BLOCKED] Script blocked due to: " .. activityType)
                debugPrint("Script blocked: " .. scriptId, "ERROR")
            end
            error("Script execution blocked due to malicious activity: " .. activityType)
        end
    end, "Malicious activity processing")
end

local function SetupGameServiceHooks()
    SafeCall(function()
        if not getrawmetatable or not setrawmetatable or not newcclosure or not getnamecallmethod then
            warn("Missing required functions for game service hooks")
            return
        end
        
        local gameMetatable = SafeCall(function() return getrawmetatable(game) end, "Getting game metatable")
        if not gameMetatable then 
            debugPrint("Could not get game metatable", "ERROR")
            return 
        end
        
        local originalNamecall = gameMetatable.__namecall
        if not originalNamecall then 
            debugPrint("No __namecall found in game metatable", "ERROR")
            return 
        end
        
        local newMetatable = {}
        SafeCall(function()
            for k, v in pairs(gameMetatable) do
                newMetatable[k] = v
            end
        end, "Copying game metatable")
        
        newMetatable.__namecall = newcclosure(function(self, ...)
            local success, method = SafeCall(function() return getnamecallmethod() end, "Getting namecall method")
            if not success then
                return originalNamecall(self, ...)
            end
            
            local args = {...}
            
            if IsExecutorScript() then
                SafeCall(function()
                    if method == "GetService" then
                        local serviceName = args[1]
                        LogActivity("SERVICE_ACCESS", "Accessing: " .. tostring(serviceName), 2)
                        
                        table.insert(ServiceAccess, {
                            service = serviceName,
                            timestamp = tick() - StartTime,
                            script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown")
                        })
                        
                        if serviceName == "MarketplaceService" then
                            AddMaliciousActivity("MARKETPLACE_SERVICE_ACCESS", {service = serviceName}, 4)
                        end
                    elseif method == "HttpGet" then
                        local url = args[1]
                        HTTPRequestCounter = HTTPRequestCounter + 1
                        local requestId = HTTPRequestCounter
                        local startTime = tick()
                        
                        LogActivity("LEGACY_HTTP_GET", "URL: " .. tostring(url), 5)
                        LogHTTPRequest("OUTGOING", "LEGACY_GET", url, nil, nil, nil, "game.HttpGet", requestId, args, nil, nil, {start_time = startTime})
                        
                        local result = originalNamecall(self, unpack(args))
                        local endTime = tick()
                        
                        LogHTTPRequest("INCOMING", "LEGACY_GET", url, nil, result, nil, "game.HttpGet", requestId, args, 200, {}, {
                            start_time = startTime,
                            end_time = endTime,
                            duration = endTime - startTime
                        })
                        
                        table.insert(NetworkRequests, {
                            method = "Legacy_HttpGet",
                            url = url,
                            timestamp = tick() - StartTime,
                            script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown"),
                            args = args
                        })
                        
                        AnalyzeNetworkRequest("Legacy_HttpGet", url, nil)
                        return result
                    elseif method == "HttpPost" then
                        local url = args[1]
                        local data = args[2]
                        HTTPRequestCounter = HTTPRequestCounter + 1
                        local requestId = HTTPRequestCounter
                        local startTime = tick()
                        
                        LogActivity("LEGACY_HTTP_POST", "URL: " .. tostring(url), 6)
                        LogHTTPRequest("OUTGOING", "LEGACY_POST", url, data, nil, nil, "game.HttpPost", requestId, args, nil, nil, {start_time = startTime})
                        
                        local result = originalNamecall(self, unpack(args))
                        local endTime = tick()
                        
                        LogHTTPRequest("INCOMING", "LEGACY_POST", url, data, result, nil, "game.HttpPost", requestId, args, 200, {}, {
                            start_time = startTime,
                            end_time = endTime,
                            duration = endTime - startTime
                        })
                        
                        table.insert(NetworkRequests, {
                            method = "Legacy_HttpPost",
                            url = url,
                            data = data,
                            timestamp = tick() - StartTime,
                            script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown"),
                            args = args
                        })
                        
                        AnalyzeNetworkRequest("Legacy_HttpPost", url, data)
                        return result
                    end
                end, "Game service hook processing")
            end
            
            return originalNamecall(self, ...)
        end)
        
        SafeCall(function()
            setrawmetatable(game, newMetatable)
            table.insert(HookedFunctions, {type = "game_namecall", original = originalNamecall})
            debugPrint("Game service hooks installed", "INFO")
        end, "Setting game metatable")
    end, "Game service hooks setup")
end

local function SetupHttpServiceHooks()
    SafeCall(function()
        if not HttpService then 
            debugPrint("HttpService not available", "WARN")
            return 
        end
        
        local httpMetatable = SafeCall(function() return getrawmetatable(HttpService) end, "Getting HttpService metatable")
        if not httpMetatable then 
            debugPrint("Could not get HttpService metatable", "ERROR")
            return 
        end
        
        local originalNamecall = httpMetatable.__namecall
        if not originalNamecall then 
            debugPrint("No __namecall found in HttpService metatable", "ERROR")
            return 
        end
        
        local newMetatable = {}
        SafeCall(function()
            for k, v in pairs(httpMetatable) do
                newMetatable[k] = v
            end
        end, "Copying HttpService metatable")
        
        newMetatable.__namecall = newcclosure(function(self, ...)
            local success, method = SafeCall(function() return getnamecallmethod() end, "Getting namecall method")
            if not success then
                return originalNamecall(self, ...)
            end
            
            local args = {...}
            
            if IsExecutorScript() then
                SafeCall(function()
                    if method == "PostAsync" then
                        local url = args[1]
                        local data = args[2]
                        local headers = args[3]
                        HTTPRequestCounter = HTTPRequestCounter + 1
                        local requestId = HTTPRequestCounter
                        local startTime = tick()
                        
                        LogActivity("HTTP_POST", "URL: " .. tostring(url), 4)
                        LogHTTPRequest("OUTGOING", "POST", url, data, nil, headers, "HttpService.PostAsync", requestId, args, nil, nil, {start_time = startTime})
                        
                        local result = originalNamecall(self, unpack(args))
                        local endTime = tick()
                        
                        local responseCode = nil
                        local responseHeaders = {}
                        if type(result) == "table" then
                            responseCode = result.StatusCode or result.status_code
                            responseHeaders = result.Headers or result.headers or {}
                        end
                        
                        LogHTTPRequest("INCOMING", "POST", url, data, result, headers, "HttpService.PostAsync", requestId, args, responseCode, responseHeaders, {
                            start_time = startTime,
                            end_time = endTime,
                            duration = endTime - startTime
                        })
                        
                        table.insert(NetworkRequests, {
                            method = "PostAsync",
                            url = url,
                            data = data,
                            headers = headers,
                            response = result,
                            response_code = responseCode,
                            timestamp = tick() - StartTime,
                            duration = endTime - startTime,
                            script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown"),
                            args = args,
                            packet_sizes = {
                                request = data and #tostring(data) or 0,
                                response = result and #tostring(result) or 0
                            }
                        })
                        
                        AnalyzeNetworkRequest("PostAsync", url, data)
                        return result
                    elseif method == "GetAsync" then
                        local url = args[1]
                        local headers = args[2]
                        HTTPRequestCounter = HTTPRequestCounter + 1
                        local requestId = HTTPRequestCounter
                        local startTime = tick()
                        
                        LogActivity("HTTP_GET", "URL: " .. tostring(url), 3)
                        LogHTTPRequest("OUTGOING", "GET", url, nil, nil, headers, "HttpService.GetAsync", requestId, args, nil, nil, {start_time = startTime})
                        
                        local result = originalNamecall(self, unpack(args))
                        local endTime = tick()
                        
                        LogHTTPRequest("INCOMING", "GET", url, nil, result, headers, "HttpService.GetAsync", requestId, args, 200, {}, {
                            start_time = startTime,
                            end_time = endTime,
                            duration = endTime - startTime
                        })
                        
                        table.insert(NetworkRequests, {
                            method = "GetAsync",
                            url = url,
                            headers = headers,
                            response = result,
                            timestamp = tick() - StartTime,
                            duration = endTime - startTime,
                            script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown"),
                            args = args,
                            packet_sizes = {
                                request = 0,
                                response = result and #tostring(result) or 0
                            }
                        })
                        
                        AnalyzeNetworkRequest("GetAsync", url, nil)
                        return result
                    elseif method == "RequestAsync" then
                        local requestData = args[1]
                        local url = requestData and (requestData.Url or requestData.url) or "Unknown"
                        local reqMethod = requestData and (requestData.Method or requestData.method) or "Unknown"
                        local headers = requestData and (requestData.Headers or requestData.headers) or {}
                        local body = requestData and (requestData.Body or requestData.body) or nil
                        HTTPRequestCounter = HTTPRequestCounter + 1
                        local requestId = HTTPRequestCounter
                        local startTime = tick()
                        
                        LogActivity("HTTP_REQUEST", reqMethod .. " -> " .. tostring(url), 4)
                        LogHTTPRequest("OUTGOING", reqMethod, url, body, nil, headers, "HttpService.RequestAsync", requestId, args, nil, nil, {start_time = startTime})
                        
                        local result = originalNamecall(self, unpack(args))
                        local endTime = tick()
                        
                        local responseBody = nil
                        local responseCode = nil
                        local responseHeaders = {}
                        if result and type(result) == "table" then
                            responseBody = result.Body
                            responseCode = result.StatusCode
                            responseHeaders = result.Headers or {}
                        end
                        
                        LogHTTPRequest("INCOMING", reqMethod, url, body, responseBody, headers, "HttpService.RequestAsync", requestId, args, responseCode, responseHeaders, {
                            start_time = startTime,
                            end_time = endTime,
                            duration = endTime - startTime
                        })
                        
                        table.insert(NetworkRequests, {
                            method = "RequestAsync_" .. reqMethod,
                            url = url,
                            data = requestData,
                            response = result,
                            response_code = responseCode,
                            timestamp = tick() - StartTime,
                            duration = endTime - startTime,
                            script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown"),
                            args = args,
                            packet_sizes = {
                                request = body and #tostring(body) or 0,
                                response = responseBody and #tostring(responseBody) or 0
                            }
                        })
                        
                        AnalyzeNetworkRequest("RequestAsync", url, body)
                        return result
                    elseif method == "JSONEncode" then
                        LogActivity("JSON_ENCODE", "Data encoding", 1)
                    elseif method == "JSONDecode" then
                        LogActivity("JSON_DECODE", "Data decoding", 1)
                    end
                end, "HTTP service hook processing")
            end
            
            return originalNamecall(self, ...)
        end)
        
        SafeCall(function()
            setrawmetatable(HttpService, newMetatable)
            table.insert(HookedFunctions, {type = "httpservice_namecall", original = originalNamecall})
            debugPrint("HTTP service hooks installed", "INFO")
        end, "Setting HttpService metatable")
    end, "HTTP service hooks setup")
end

local function SetupMarketplaceHooks()
    SafeCall(function()
        if not MarketplaceService then 
            debugPrint("MarketplaceService not available", "WARN")
            return 
        end
        
        local marketMetatable = SafeCall(function() return getrawmetatable(MarketplaceService) end, "Getting MarketplaceService metatable")
        if not marketMetatable then 
            debugPrint("Could not get MarketplaceService metatable", "ERROR")
            return 
        end
        
        local originalNamecall = marketMetatable.__namecall
        if not originalNamecall then 
            debugPrint("No __namecall found in MarketplaceService metatable", "ERROR")
            return 
        end
        
        local newMetatable = {}
        SafeCall(function()
            for k, v in pairs(marketMetatable) do
                newMetatable[k] = v
            end
        end, "Copying MarketplaceService metatable")
        
        newMetatable.__namecall = newcclosure(function(self, ...)
            local success, method = SafeCall(function() return getnamecallmethod() end, "Getting namecall method")
            if not success then
                return originalNamecall(self, ...)
            end
            
            local args = {...}
            
            if IsExecutorScript() then
                SafeCall(function()
                    if method == "PromptPurchase" then
                        local player = args[1]
                        local assetId = args[2]
                        
                        table.insert(PurchaseAttempts, {
                            type = "Asset",
                            player = tostring(player),
                            id = assetId,
                            timestamp = tick() - StartTime
                        })
                        
                        AddMaliciousActivity("ASSET_PURCHASE_PROMPT", {
                            player = tostring(player),
                            assetId = assetId,
                            method = "PromptPurchase"
                        }, 9)
                        
                        LogActivity("ROBUX_PROMPT", "Player: " .. tostring(player) .. " Asset: " .. tostring(assetId), 10)
                    elseif method == "PromptProductPurchase" then
                        local player = args[1]
                        local productId = args[2]
                        
                        table.insert(PurchaseAttempts, {
                            type = "Product",
                            player = tostring(player),
                            id = productId,
                            timestamp = tick() - StartTime
                        })
                        
                        AddMaliciousActivity("PRODUCT_PURCHASE_PROMPT", {
                            player = tostring(player),
                            productId = productId,
                            method = "PromptProductPurchase"
                        }, 10)
                        
                        LogActivity("PRODUCT_PROMPT", "Player: " .. tostring(player) .. " Product: " .. tostring(productId), 10)
                    elseif method == "PromptGamePassPurchase" then
                        local player = args[1]
                        local gamePassId = args[2]
                        
                        table.insert(PurchaseAttempts, {
                            type = "GamePass",
                            player = tostring(player),
                            id = gamePassId,
                            timestamp = tick() - StartTime
                        })
                        
                        AddMaliciousActivity("GAMEPASS_PURCHASE_PROMPT", {
                            player = tostring(player),
                            gamePassId = gamePassId,
                            method = "PromptGamePassPurchase"
                        }, 9)
                        
                        LogActivity("GAMEPASS_PROMPT", "Player: " .. tostring(player) .. " GamePass: " .. tostring(gamePassId), 9)
                    end
                end, "Marketplace hook processing")
            end
            
            return originalNamecall(self, ...)
        end)
        
        SafeCall(function()
            setrawmetatable(MarketplaceService, newMetatable)
            table.insert(HookedFunctions, {type = "marketplace_namecall", original = originalNamecall})
            debugPrint("Marketplace hooks installed", "INFO")
        end, "Setting MarketplaceService metatable")
    end, "Marketplace hooks setup")
end

local function SetupTeleportHooks()
    SafeCall(function()
        if not TeleportService then 
            debugPrint("TeleportService not available", "WARN")
            return 
        end
        
        local teleportMetatable = SafeCall(function() return getrawmetatable(TeleportService) end, "Getting TeleportService metatable")
        if not teleportMetatable then 
            debugPrint("Could not get TeleportService metatable", "ERROR")
            return 
        end
        
        local originalNamecall = teleportMetatable.__namecall
        if not originalNamecall then 
            debugPrint("No __namecall found in TeleportService metatable", "ERROR")
            return 
        end
        
        local newMetatable = {}
        SafeCall(function()
            for k, v in pairs(teleportMetatable) do
                newMetatable[k] = v
            end
        end, "Copying TeleportService metatable")
        
        newMetatable.__namecall = newcclosure(function(self, ...)
            local success, method = SafeCall(function() return getnamecallmethod() end, "Getting namecall method")
            if not success then
                return originalNamecall(self, ...)
            end
            
            local args = {...}
            
            if IsExecutorScript() and method:find("Teleport") then
                SafeCall(function()
                    AddMaliciousActivity("FORCED_TELEPORT", {
                        method = method,
                        args = args,
                        argCount = #args
                    }, 8)
                    
                    LogActivity("TELEPORT", method .. " called with " .. #args .. " arguments", 8)
                end, "Teleport hook processing")
            end
            
            return originalNamecall(self, ...)
        end)
        
        SafeCall(function()
            setrawmetatable(TeleportService, newMetatable)
            table.insert(HookedFunctions, {type = "teleport_namecall", original = originalNamecall})
            debugPrint("Teleport hooks installed", "INFO")
        end, "Setting TeleportService metatable")
    end, "Teleport hooks setup")
end

local function SetupUserInputHooks()
    SafeCall(function()
        if not UserInputService then 
            debugPrint("UserInputService not available", "WARN")
            return 
        end
        
        local uisMetatable = SafeCall(function() return getrawmetatable(UserInputService) end, "Getting UserInputService metatable")
        if not uisMetatable then 
            debugPrint("Could not get UserInputService metatable", "ERROR")
            return 
        end
        
        local originalIndex = uisMetatable.__index
        if not originalIndex then 
            debugPrint("No __index found in UserInputService metatable", "ERROR")
            return 
        end
        
        local newMetatable = {}
        SafeCall(function()
            for k, v in pairs(uisMetatable) do
                newMetatable[k] = v
            end
        end, "Copying UserInputService metatable")
        
        newMetatable.__index = newcclosure(function(self, key)
            if IsExecutorScript() then
                SafeCall(function()
                    if key == "InputBegan" then
                        AddMaliciousActivity("KEYLOGGER_SETUP", {event = "InputBegan"}, 8)
                        LogActivity("KEYSTROKE_MONITOR", "InputBegan event accessed", 8)
                        
                        local originalEvent = originalIndex(self, key)
                        if originalEvent and originalEvent.Connect then
                            local originalConnect = originalEvent.Connect
                            
                            originalEvent.Connect = function(self, callback)
                                AddMaliciousActivity("KEYLOGGER_ACTIVE", {}, 9)
                                LogActivity("KEYSTROKE_LOGGER", "InputBegan callback connected", 9)
                                
                                local wrappedCallback = function(input, processed)
                                    SafeCall(function()
                                        if MonitoringActive then
                                            table.insert(KeystrokeLog, {
                                                keyCode = tostring(input.KeyCode),
                                                userInputType = tostring(input.UserInputType),
                                                processed = processed,
                                                timestamp = tick() - StartTime,
                                                script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown")
                                            })
                                            
                                            if input.UserInputType == Enum.UserInputType.Keyboard then
                                                AddMaliciousActivity("KEYSTROKE_LOGGED", {
                                                    key = tostring(input.KeyCode),
                                                    processed = processed
                                                }, 7)
                                            end
                                        end
                                    end, "Keystroke logging")
                                    return callback(input, processed)
                                end
                                
                                return originalConnect(originalEvent, wrappedCallback)
                            end
                        end
                        
                        return originalEvent
                    elseif key == "InputChanged" then
                        AddMaliciousActivity("INPUT_CHANGE_MONITORING", {event = "InputChanged"}, 6)
                        LogActivity("INPUT_MONITOR", "InputChanged event accessed", 6)
                    end
                end, "UserInput hook processing")
            end
            
            return originalIndex(self, key)
        end)
        
        SafeCall(function()
            setrawmetatable(UserInputService, newMetatable)
            table.insert(HookedFunctions, {type = "userinput_index", original = originalIndex})
            debugPrint("UserInput hooks installed", "INFO")
        end, "Setting UserInputService metatable")
    end, "UserInput hooks setup")
end

local function SetupFileSystemHooks()
    SafeCall(function()
        if writefile then
            SafeCall(function()
                OriginalFunctions.writefile = writefile
                if getgenv then
                    getgenv().writefile = function(filename, content)
                        if IsExecutorScript() then
                            SafeCall(function()
                                LogActivity("FILE_WRITE", "Writing to: " .. filename, 3)
                                
                                table.insert(FileOperations, {
                                    operation = "WRITE",
                                    filename = filename,
                                    size = #tostring(content),
                                    timestamp = tick() - StartTime,
                                    script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown")
                                })
                                
                                AnalyzeFileOperation("WRITE", filename, content)
                            end, "File write logging")
                        end
                        return OriginalFunctions.writefile(filename, content)
                    end
                end
            end, "Setting up writefile hook")
        end
        
        if readfile then
            SafeCall(function()
                OriginalFunctions.readfile = readfile
                if getgenv then
                    getgenv().readfile = function(filename)
                        if IsExecutorScript() then
                            SafeCall(function()
                                LogActivity("FILE_READ", "Reading: " .. filename, 2)
                                
                                table.insert(FileOperations, {
                                    operation = "READ",
                                    filename = filename,
                                    timestamp = tick() - StartTime,
                                    script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown")
                                })
                                
                                AnalyzeFileOperation("READ", filename, nil)
                            end, "File read logging")
                        end
                        return OriginalFunctions.readfile(filename)
                    end
                end
            end, "Setting up readfile hook")
        end
        
        if appendfile then
            SafeCall(function()
                OriginalFunctions.appendfile = appendfile
                if getgenv then
                    getgenv().appendfile = function(filename, content)
                        if IsExecutorScript() then
                            SafeCall(function()
                                LogActivity("FILE_APPEND", "Appending to: " .. filename, 3)
                                
                                table.insert(FileOperations, {
                                    operation = "APPEND",
                                    filename = filename,
                                    size = #tostring(content),
                                    timestamp = tick() - StartTime,
                                    script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown")
                                })
                                
                                AnalyzeFileOperation("APPEND", filename, content)
                            end, "File append logging")
                        end
                        return OriginalFunctions.appendfile(filename, content)
                    end
                end
            end, "Setting up appendfile hook")
        end
        
        if makefolder then
            SafeCall(function()
                OriginalFunctions.makefolder = makefolder
                if getgenv then
                    getgenv().makefolder = function(foldername)
                        if IsExecutorScript() then
                            SafeCall(function()
                                LogActivity("FOLDER_CREATE", "Creating folder: " .. foldername, 2)
                                
                                table.insert(FileOperations, {
                                    operation = "CREATE_FOLDER",
                                    filename = foldername,
                                    timestamp = tick() - StartTime,
                                    script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown")
                                })
                            end, "Folder creation logging")
                        end
                        return OriginalFunctions.makefolder(foldername)
                    end
                end
            end, "Setting up makefolder hook")
        end
        
        debugPrint("File system hooks installed", "INFO")
    end, "File system hooks setup")
end

local function SetupRequestHooks()
    SafeCall(function()
        if request then
            SafeCall(function()
                OriginalFunctions.request = request
                if getgenv then
                    getgenv().request = function(requestData)
                        if IsExecutorScript() then
                            local url = "Unknown"
                            local method = "GET"
                            local headers = {}
                            local body = nil
                            HTTPRequestCounter = HTTPRequestCounter + 1
                            local requestId = HTTPRequestCounter
                            local startTime = tick()
                            
                            SafeCall(function()
                                url = requestData.Url or requestData.url or "Unknown"
                                method = requestData.Method or requestData.method or "GET"
                                headers = requestData.Headers or requestData.headers or {}
                                body = requestData.Body or requestData.body
                                
                                LogActivity("REQUEST_FUNCTION", method .. " -> " .. tostring(url), 4)
                                LogHTTPRequest("OUTGOING", method, url, body, nil, headers, "request()", requestId, {requestData}, nil, nil, {start_time = startTime})
                                
                                table.insert(NetworkRequests, {
                                    method = "request_" .. method,
                                    url = url,
                                    data = requestData,
                                    timestamp = tick() - StartTime,
                                    script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown"),
                                    packet_sizes = {
                                        request = body and #tostring(body) or 0
                                    }
                                })
                                
                                AnalyzeNetworkRequest("request", url, body)
                            end, "Request function logging")
                        end
                        
                        local result = OriginalFunctions.request(requestData)
                        local endTime = tick()
                        
                        if IsExecutorScript() then
                            SafeCall(function()
                                local responseBody = nil
                                local responseCode = nil
                                local responseHeaders = {}
                                if result and type(result) == "table" then
                                    responseBody = result.Body
                                    responseCode = result.StatusCode
                                    responseHeaders = result.Headers or {}
                                end
                                
                                LogHTTPRequest("INCOMING", method, url, body, responseBody, headers, "request()", requestId, {requestData}, responseCode, responseHeaders, {
                                    start_time = startTime,
                                    end_time = endTime,
                                    duration = endTime - startTime
                                })
                            end, "Request response logging")
                        end
                        
                        return result
                    end
                end
            end, "Setting up request hook")
        end
        
        if http_request then
            SafeCall(function()
                OriginalFunctions.http_request = http_request
                if getgenv then
                    getgenv().http_request = function(requestData)
                        if IsExecutorScript() then
                            local url = "Unknown"
                            local method = "GET"
                            local headers = {}
                            local body = nil
                            HTTPRequestCounter = HTTPRequestCounter + 1
                            local requestId = HTTPRequestCounter
                            local startTime = tick()
                            
                            SafeCall(function()
                                url = requestData.Url or requestData.url or "Unknown"
                                method = requestData.Method or requestData.method or "GET"
                                headers = requestData.Headers or requestData.headers or {}
                                body = requestData.Body or requestData.body
                                
                                LogActivity("HTTP_REQUEST_FUNCTION", method .. " -> " .. tostring(url), 4)
                                LogHTTPRequest("OUTGOING", method, url, body, nil, headers, "http_request()", requestId, {requestData}, nil, nil, {start_time = startTime})
                                
                                table.insert(NetworkRequests, {
                                    method = "http_request_" .. method,
                                    url = url,
                                    data = requestData,
                                    timestamp = tick() - StartTime,
                                    script = tostring(SafeCall(function() return getcallingscript() end) and getcallingscript() or "Unknown"),
                                    packet_sizes = {
                                        request = body and #tostring(body) or 0
                                    }
                                })
                                
                                AnalyzeNetworkRequest("http_request", url, body)
                            end, "HTTP request function logging")
                        end
                        
                        local result = OriginalFunctions.http_request(requestData)
                        local endTime = tick()
                        
                        if IsExecutorScript() then
                            SafeCall(function()
                                local responseBody = nil
                                local responseCode = nil
                                local responseHeaders = {}
                                if result and type(result) == "table" then
                                    responseBody = result.Body
                                    responseCode = result.StatusCode
                                    responseHeaders = result.Headers or {}
                                end
                                
                                LogHTTPRequest("INCOMING", method, url, body, responseBody, headers, "http_request()", requestId, {requestData}, responseCode, responseHeaders, {
                                    start_time = startTime,
                                    end_time = endTime,
                                    duration = endTime - startTime
                                })
                            end, "HTTP request response logging")
                        end
                        
                        return result
                    end
                end
            end, "Setting up http_request hook")
        end
        
        debugPrint("Request hooks installed", "INFO")
    end, "Request hooks setup")
end

local function SetupEnvironmentHooks()
    SafeCall(function()
        if getgenv then
            SafeCall(function()
                OriginalFunctions.getgenv = getgenv
                getgenv().getgenv = function()
                    if IsExecutorScript() then
                        SafeCall(function()
                            AddMaliciousActivity("EXECUTOR_ENV_ACCESS", {}, 5)
                            LogActivity("ENVIRONMENT_ACCESS", "getgenv() called", 5)
                        end, "getgenv logging")
                    end
                    return OriginalFunctions.getgenv()
                end
            end, "Setting up getgenv hook")
        end
        
        if getrenv then
            SafeCall(function()
                OriginalFunctions.getrenv = getrenv
                if getgenv then
                    getgenv().getrenv = function()
                        if IsExecutorScript() then
                            SafeCall(function()
                                AddMaliciousActivity("REAL_ENV_ACCESS", {}, 6)
                                LogActivity("ENVIRONMENT_ACCESS", "getrenv() called", 6)
                            end, "getrenv logging")
                        end
                        return OriginalFunctions.getrenv()
                    end
                end
            end, "Setting up getrenv hook")
        end
        
        if getrawmetatable then
            SafeCall(function()
                OriginalFunctions.getrawmetatable = getrawmetatable
                if getgenv then
                    getgenv().getrawmetatable = function(obj)
                        if IsExecutorScript() then
                            SafeCall(function()
                                AddMaliciousActivity("METATABLE_ACCESS", {object = tostring(obj)}, 6)
                                LogActivity("METATABLE_ACCESS", "getrawmetatable called on: " .. tostring(obj), 6)
                            end, "getrawmetatable logging")
                        end
                        return OriginalFunctions.getrawmetatable(obj)
                    end
                end
            end, "Setting up getrawmetatable hook")
        end
        
        if setrawmetatable then
            SafeCall(function()
                OriginalFunctions.setrawmetatable = setrawmetatable
                if getgenv then
                    getgenv().setrawmetatable = function(obj, metatable)
                        if IsExecutorScript() then
                            SafeCall(function()
                                AddMaliciousActivity("METATABLE_MODIFICATION", {object = tostring(obj)}, 7)
                                LogActivity("METATABLE_MODIFY", "setrawmetatable called on: " .. tostring(obj), 7)
                            end, "setrawmetatable logging")
                        end
                        return OriginalFunctions.setrawmetatable(obj, metatable)
                    end
                end
            end, "Setting up setrawmetatable hook")
        end
        
        debugPrint("Environment hooks installed", "INFO")
    end, "Environment hooks setup")
end

local function SetupChatMonitoring()
    SafeCall(function()
        if not LocalPlayer then
            debugPrint("LocalPlayer not available for chat monitoring", "WARN")
            return
        end
        
        SafeCall(function()
            LocalPlayer.Chatted:Connect(function(message)
                SafeCall(function()
                    if message:lower() == "stop" then
                        MonitoringActive = false
                        print("MONITORING STOPPED BY USER COMMAND")
                        return
                    end
                    
                    table.insert(ChatInterceptions, {
                        player = tostring(LocalPlayer),
                        message = message,
                        timestamp = tick() - StartTime
                    })
                    
                    AnalyzeChatMessage(LocalPlayer, message)
                end, "Processing LocalPlayer chat")
            end)
        end, "Setting up LocalPlayer chat monitoring")
        
        SafeCall(function()
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Chatted then
                    SafeCall(function()
                        player.Chatted:Connect(function(message)
                            SafeCall(function()
                                table.insert(ChatInterceptions, {
                                    player = tostring(player),
                                    message = message,
                                    timestamp = tick() - StartTime
                                })
                                
                                AnalyzeChatMessage(player, message)
                            end, "Processing player chat: " .. tostring(player))
                        end)
                    end, "Setting up chat monitoring for: " .. tostring(player))
                end
            end
        end, "Setting up existing players chat monitoring")
        
        SafeCall(function()
            Players.PlayerAdded:Connect(function(player)
                SafeCall(function()
                    if player ~= LocalPlayer and player.Chatted then
                        player.Chatted:Connect(function(message)
                            SafeCall(function()
                                table.insert(ChatInterceptions, {
                                    player = tostring(player),
                                    message = message,
                                    timestamp = tick() - StartTime
                                })
                                
                                AnalyzeChatMessage(player, message)
                            end, "Processing new player chat: " .. tostring(player))
                        end)
                    end
                end, "Setting up new player chat monitoring: " .. tostring(player))
            end)
        end, "Setting up PlayerAdded chat monitoring")
        
        debugPrint("Chat monitoring installed", "INFO")
    end, "Chat monitoring setup")
end

function AnalyzeNetworkRequest(method, url, data)
    SafeCall(function()
        local urlStr = tostring(url):lower()
        
        local webhookPatterns = {
            "discord%.com/api/webhooks/",
            "discordapp%.com/api/webhooks/",
            "canary%.discord%.com/api/webhooks/",
            "ptb%.discord%.com/api/webhooks/"
        }
        
        for _, pattern in pairs(webhookPatterns) do
            if string.match(urlStr, pattern) then
                table.insert(DataCollectionPatterns, {
                    type = "webhook_transmission",
                    url = url,
                    data = data,
                    timestamp = tick() - StartTime
                })
                
                AddMaliciousActivity("WEBHOOK_DATA_TRANSMISSION", {
                    method = method,
                    url = url,
                    webhook_type = "DISCORD"
                }, 9)
            end
        end
        
        local suspiciousServices = {
            "paste%.ee", "pastebin%.com", "hastebin%.com", "0x0%.st", "file%.io",
            "anonfiles%.com", "mega%.nz", "t%.me", "api%.telegram%.org"
        }
        
        for _, pattern in pairs(suspiciousServices) do
            if string.match(urlStr, pattern) then
                AddMaliciousActivity("EXTERNAL_DATA_UPLOAD", {
                    method = method,
                    url = url,
                    service = pattern
                }, 7)
            end
        end
        
        if data and method:upper() == "POST" then
            AnalyzeDataTransmission(url, data)
        end
    end, "Network request analysis")
end

function AnalyzeDataTransmission(url, data)
    SafeCall(function()
        local dataStr = tostring(data)
        local patterns = 0
        
        local playerDataPatterns = {
            "userid", "username", "displayname", "accountage", "premium", "robux",
            "placeid", "jobid", "hwid", "fingerprint", "ip", "country"
        }
        
        for _, pattern in pairs(playerDataPatterns) do
            if dataStr:lower():find(pattern) then
                patterns = patterns + 1
            end
        end
        
        if patterns >= CONFIG.DATA_STEALER_THRESHOLD then
            AddMaliciousActivity("PLAYER_DATA_HARVESTING", {
                url = url,
                patterns_matched = patterns,
                data_length = #dataStr
            }, 8)
        end
        
        if dataStr:find("game:GetService") or dataStr:find("Players:GetPlayers") then
            AddMaliciousActivity("GAME_DATA_EXTRACTION", {
                url = url,
                contains_game_methods = true
            }, 7)
        end
    end, "Data transmission analysis")
end

function AnalyzeFileOperation(operation, filename, content)
    SafeCall(function()
        local filenameStr = tostring(filename):lower()
        
        if filenameStr:find("config") or filenameStr:find("data") or filenameStr:find("log") then
            if content and tostring(content):find("username") or tostring(content):find("userid") then
                AddMaliciousActivity("PERSONAL_DATA_STORAGE", {
                    operation = operation,
                    filename = filename
                }, 6)
            end
        end
        
        if operation == "WRITE" and content then
            local contentStr = tostring(content):lower()
            if contentStr:find("userid") and contentStr:find("username") and contentStr:find("robux") then
                AddMaliciousActivity("ACCOUNT_INFO_LOGGING", {
                    filename = filename,
                    operation = operation
                }, 8)
            end
        end
    end, "File operation analysis")
end

function AnalyzeChatMessage(player, message)
    SafeCall(function()
        local messageStr = tostring(message):lower()
        
        local phishingKeywords = {
            "free robux", "robux generator", "click here", "visit", "www.", "http", "discord.gg"
        }
        
        for _, keyword in pairs(phishingKeywords) do
            if messageStr:find(keyword) then
                AddMaliciousActivity("PHISHING_ATTEMPT", {
                    player = tostring(player),
                    message = message,
                    keyword = keyword
                }, 6)
                break
            end
        end
    end, "Chat message analysis")
end

local function DetectRobuxStealerBehavior()
    SafeCall(function()
        if #PurchaseAttempts > CONFIG.ROBUX_STEALER_THRESHOLD then
            for i = 1, #PurchaseAttempts - 1 do
                local current = PurchaseAttempts[i]
                local next = PurchaseAttempts[i + 1]
                
                if next.timestamp - current.timestamp < 2 then
                    AddMaliciousActivity("RAPID_PURCHASE_PROMPTS", {
                        first_id = current.id,
                        second_id = next.id,
                        time_difference = next.timestamp - current.timestamp
                    }, 9)
                end
            end
        end
    end, "Robux stealer behavior detection")
end

local function DetectDataStealerBehavior()
    SafeCall(function()
        local webhookRequests = 0
        local playerDataAccess = 0
        
        for _, request in pairs(NetworkRequests) do
            if tostring(request.url):lower():find("webhook") then
                webhookRequests = webhookRequests + 1
            end
        end
        
        for _, activity in pairs(ActivityLog) do
            if activity.type:find("PLAYER") or activity.type:find("USER") then
                playerDataAccess = playerDataAccess + 1
            end
        end
        
        if webhookRequests > 0 and playerDataAccess > CONFIG.DATA_STEALER_THRESHOLD then
            AddMaliciousActivity("DATA_STEALER_PATTERN", {
                webhook_requests = webhookRequests,
                data_access_attempts = playerDataAccess
            }, 9)
        end
    end, "Data stealer behavior detection")
end

local function CalculateRiskScore()
    SafeCall(function()
        DetectRobuxStealerBehavior()
        DetectDataStealerBehavior()
    end, "Running behavior detection")
    
    local score = 0
    local maxSeverity = 0
    local robuxStealerCount = 0
    local dataStealerCount = 0
    local keyloggerCount = 0
    local webhookCount = 0
    
    SafeCall(function()
        for _, activity in pairs(MaliciousActivities) do
            score = score + activity.severity
            maxSeverity = math.max(maxSeverity, activity.severity)
            
            if activity.type:find("PURCHASE") or activity.type:find("ROBUX") then
                robuxStealerCount = robuxStealerCount + 1
            elseif activity.type:find("DATA") or activity.type:find("HARVEST") then
                dataStealerCount = dataStealerCount + 1
            elseif activity.type:find("KEYSTROKE") or activity.type:find("KEYLOGGER") then
                keyloggerCount = keyloggerCount + 1
            elseif activity.type:find("WEBHOOK") then
                webhookCount = webhookCount + 1
            end
        end
    end, "Calculating risk scores")
    
    local safetyScore = math.max(0, 100 - score)
    
    return {
        total_risk = score,
        safety_score = safetyScore,
        max_severity = maxSeverity,
        activity_count = #MaliciousActivities,
        robux_stealer_activities = robuxStealerCount,
        data_stealer_activities = dataStealerCount,
        keylogger_activities = keyloggerCount,
        webhook_activities = webhookCount,
        network_requests = #NetworkRequests,
        file_operations = #FileOperations,
        keystrokes_logged = #KeystrokeLog,
        blocked_scripts = #BlockedScripts,
        http_spy_requests = #HTTPSpyLog
    }
end

local function SortMaliciousByRisk(activities)
    SafeCall(function()
        table.sort(activities, function(a, b)
            if a.severity == b.severity then
                return a.timestamp < b.timestamp
            end
            return a.severity > b.severity
        end)
    end, "Sorting activities by risk")
    return activities
end

local function SaveLogsToFile(riskScore)
    if not CONFIG.AUTO_SAVE_LOGS then return end
    
    SafeCall(function()
        local timestamp = SafeCall(function() return os.date("%Y%m%d_%H%M%S") end, "Getting timestamp") and os.date("%Y%m%d_%H%M%S") or "unknown"
        local filename = "runtime_security_" .. timestamp .. ".log"
        
        local logContent = "═══════════════════════════════════════════════════════════════════════════════\n"
        logContent = logContent .. "                      MORFEIN'S RUNTIME ANALYZER v2.2\n"
        logContent = logContent .. "═══════════════════════════════════════════════════════════════════════════════\n\n"
        logContent = logContent .. "CONFIGURATION:\n"
        logContent = logContent .. "─────────────────────────────────────────────────────────────────────────────\n"
        logContent = logContent .. "Block Malicious Scripts : " .. tostring(CONFIG.BLOCK_MALICIOUS_SCRIPTS) .. "\n"
        logContent = logContent .. "Monitor Executor Only   : " .. tostring(CONFIG.MONITOR_EXECUTOR_ONLY) .. "\n"
        logContent = logContent .. "Ignore Game Scripts     : " .. tostring(CONFIG.IGNORE_GAME_SCRIPTS) .. "\n"
        logContent = logContent .. "HTTP Spy Enabled        : " .. tostring(CONFIG.HTTP_SPY_ENABLED) .. "\n"
        logContent = logContent .. "Show All HTTP Requests  : " .. tostring(CONFIG.SHOW_ALL_HTTP_REQUESTS) .. "\n"
        logContent = logContent .. "Log HTTP Data           : " .. tostring(CONFIG.LOG_HTTP_DATA) .. "\n"
        logContent = logContent .. "Max Data Log Length     : " .. CONFIG.MAX_DATA_LOG_LENGTH .. " chars\n\n"
        
        logContent = logContent .. "MONITORING SUMMARY:\n"
        logContent = logContent .. "─────────────────────────────────────────────────────────────────────────────\n"
        logContent = logContent .. "Monitoring Duration     : " .. string.format("%.2f", tick() - StartTime) .. " seconds\n"
        logContent = logContent .. "Risk Score              : " .. riskScore.total_risk .. "\n"
        logContent = logContent .. "Safety Score            : " .. riskScore.safety_score .. "/100\n"
        logContent = logContent .. "Max Severity            : " .. riskScore.max_severity .. "/10\n"
        logContent = logContent .. "Malicious Activities    : " .. riskScore.activity_count .. "\n"
        logContent = logContent .. "Robux Stealer Signs     : " .. riskScore.robux_stealer_activities .. "\n"
        logContent = logContent .. "Data Stealer Signs      : " .. riskScore.data_stealer_activities .. "\n"
        logContent = logContent .. "Keylogger Signs         : " .. riskScore.keylogger_activities .. "\n"
        logContent = logContent .. "Webhook Activities      : " .. riskScore.webhook_activities .. "\n"
        logContent = logContent .. "Network Requests        : " .. riskScore.network_requests .. "\n"
        logContent = logContent .. "HTTP Spy Requests       : " .. riskScore.http_spy_requests .. "\n"
        logContent = logContent .. "File Operations         : " .. riskScore.file_operations .. "\n"
        logContent = logContent .. "Keystrokes Captured     : " .. riskScore.keystrokes_logged .. "\n"
        logContent = logContent .. "Blocked Scripts         : " .. riskScore.blocked_scripts .. "\n\n"
        
        logContent = logContent .. "HTTP SPY LOG (ALL REQUESTS & RESPONSES):\n"
        logContent = logContent .. "─────────────────────────────────────────────────────────────────────────────\n"
        local currentRequestId = nil
        for i, httpReq in pairs(HTTPSpyLog) do
            if currentRequestId ~= httpReq.id then
                currentRequestId = httpReq.id
                logContent = logContent .. "\n[REQUEST ID: " .. (httpReq.id or "UNKNOWN") .. "]\n"
            end
            
            logContent = logContent .. string.format("[%05.1fs] [%s] %s -> %s\n",
                httpReq.timestamp, httpReq.direction, httpReq.method, httpReq.url)
            logContent = logContent .. "  Source: " .. (httpReq.source or "Unknown") .. "\n"
            logContent = logContent .. "  Script: " .. (httpReq.script or "Unknown") .. "\n"
            
            if httpReq.direction == "OUTGOING" then
                logContent = logContent .. "  Request Size: " .. (httpReq.request_size or 0) .. " bytes\n"
                if httpReq.headers and next(httpReq.headers) then
                    logContent = logContent .. "  Request Headers: " .. SafeJSONEncode(httpReq.headers) .. "\n"
                end
                if httpReq.request_data and httpReq.request_data ~= "[LOGGING_DISABLED]" then
                    logContent = logContent .. "  Request Data: " .. httpReq.request_data .. "\n"
                end
            elseif httpReq.direction == "INCOMING" then
                logContent = logContent .. "  Response Size: " .. (httpReq.response_size or 0) .. " bytes\n"
                if httpReq.response_data and httpReq.response_data ~= "[LOGGING_DISABLED]" then
                    logContent = logContent .. "  Response Data: " .. httpReq.response_data .. "\n"
                end
            end
            logContent = logContent .. "\n"
        end
        
        logContent = logContent .. "\nTOP " .. CONFIG.MAX_REPORT_ACTIVITIES .. " MALICIOUS ACTIVITIES:\n"
        logContent = logContent .. "─────────────────────────────────────────────────────────────────────────────\n"
        local sortedActivities = SortMaliciousByRisk(MaliciousActivities)
        for i = 1, math.min(CONFIG.MAX_REPORT_ACTIVITIES, #sortedActivities) do
            local activity = sortedActivities[i]
            logContent = logContent .. string.format("[%02d] [SEV:%02d] [%05.1fs] %s\n",
                i, activity.severity, activity.timestamp, activity.type)
            logContent = logContent .. "     Script: " .. (activity.script or "Unknown") .. "\n"
            logContent = logContent .. "     Data: " .. SafeJSONEncode(activity.data or {}) .. "\n\n"
        end
        
        if CONFIG.BLOCK_MALICIOUS_SCRIPTS and next(BlockedScripts) then
            logContent = logContent .. "BLOCKED SCRIPTS:\n"
            logContent = logContent .. "─────────────────────────────────────────────────────────────────────────────\n"
            for scriptId, blockData in pairs(BlockedScripts) do
                logContent = logContent .. string.format("[%05.1fs] %s - Reason: %s\n",
                    blockData.timestamp, scriptId, blockData.reason)
            end
            logContent = logContent .. "\n"
        end
        
        logContent = logContent .. "NETWORK REQUESTS:\n"
        logContent = logContent .. "─────────────────────────────────────────────────────────────────────────────\n"
        for i, request in pairs(NetworkRequests) do
            logContent = logContent .. string.format("[%05.1fs] %s -> %s\n",
                request.timestamp, request.method, request.url)
            logContent = logContent .. "  Script: " .. (request.script or "Unknown") .. "\n\n"
        end
        
        if writefile and OriginalFunctions.writefile then
            OriginalFunctions.writefile(filename, logContent)
            print("Log file saved: " .. filename)
        end
    end, "Log file saving")
end

function ScriptTester:StartMonitoring()
    SafeCall(function()
        print("\n")
        print("╔══════════════════════════════════════════════════════════════════════════════╗")
        print("║                               RUNTIME ANALYZER v2.2                         ║")
        print("║                              morefein was here                              ║")
        print("╚══════════════════════════════════════════════════════════════════════════════╝")
        print("")
        print("CONFIGURATION:")
        print("  Block Malicious Scripts: " .. tostring(CONFIG.BLOCK_MALICIOUS_SCRIPTS))
        print("  Monitor Executor Only: " .. tostring(CONFIG.MONITOR_EXECUTOR_ONLY))
        print("  Show Detections: " .. tostring(CONFIG.SHOW_DETECTIONS))
        print("  HTTP Spy Enabled: " .. tostring(CONFIG.HTTP_SPY_ENABLED))
        print("  Show All HTTP Requests: " .. tostring(CONFIG.SHOW_ALL_HTTP_REQUESTS))
        print("  Log HTTP Data: " .. tostring(CONFIG.LOG_HTTP_DATA))
        print("  Max Data Log Length: " .. CONFIG.MAX_DATA_LOG_LENGTH .. " chars")
        print("  Debug Mode: " .. tostring(CONFIG.DEBUG_MODE))
        print("  Show Packet Details: " .. tostring(CONFIG.SHOW_PACKET_DETAILS))
        print("  Show Hex Dumps: " .. tostring(CONFIG.SHOW_HEX_DUMPS))
        print("")
        print("┌─ INITIALIZING HOOKS ─────────────────────────────────────────────────────────┐")
        print("│ Setting up monitoring systems...")
        print("└──────────────────────────────────────────────────────────────────────────────┘")
        
        ActivityLog = {}
        MaliciousActivities = {}
        NetworkRequests = {}
        FileOperations = {}
        KeystrokeLog = {}
        ChatInterceptions = {}
        ServiceAccess = {}
        OriginalFunctions = {}
        HookedFunctions = {}
        PurchaseAttempts = {}
        DataCollectionPatterns = {}
        BlockedScripts = {}
        HTTPSpyLog = {}
        HTTPRequestCounter = 0
        
        MonitoringActive = true
        StartTime = tick()
        
        debugPrint("Starting hook installation", "INFO")
        
        CreateUI()
        
        SetupGameServiceHooks()
        SetupHttpServiceHooks()
        SetupMarketplaceHooks()
        SetupTeleportHooks()
        SetupUserInputHooks()
        SetupFileSystemHooks()
        SetupRequestHooks()
        SetupEnvironmentHooks()
        SetupChatMonitoring()
        
        print("")
        print("┌─ MONITORING ACTIVE ──────────────────────────────────────────────────────────┐")
        print("│ ✅ All hooks installed successfully")
        print("│ 🟢 Runtime monitoring active")
        print("│ 🌐 HTTP Spy monitoring active (IN/OUT)")
        print("│ 📊 Enhanced packet analysis enabled")
        print("│ 🔍 Hex dump analysis enabled")
        print("│ 📋 Detailed argument logging enabled")
        print("│ 🖥️  GUI interface available")
        if CONFIG.BLOCK_MALICIOUS_SCRIPTS then
            print("│ 🔴 Malicious scripts will be BLOCKED")
        else
            print("│ 🟡 Malicious scripts will be LOGGED ONLY")
        end
        print("│ Execute your test script now")
        print("│ Type 'stop' in chat to end monitoring")
        print("│ Maximum duration: " .. CONFIG.MONITOR_DURATION .. " seconds")
        print("└──────────────────────────────────────────────────────────────────────────────┘")
        
        spawn(function()
            SafeCall(function()
                while MonitoringActive and (tick() - StartTime) < CONFIG.MONITOR_DURATION do
                    wait(1)
                end
                
                if MonitoringActive then
                    MonitoringActive = false
                    debugPrint("Monitoring timeout reached", "INFO")
                    print("Monitoring timeout reached")
                    if UI.StatusLabel then
                        UI.StatusLabel.Text = "STATUS: MONITORING TIMEOUT"
                        UI.StatusLabel.TextColor3 = Color3.fromRGB(255, 170, 85)
                    end
                end
                
                local riskScore = CalculateRiskScore()
                
                if CONFIG.SHOW_ANALYSIS_DETAILS then
                    print("")
                    print("╔══════════════════════════════════════════════════════════════════════════════╗")
                    print("║                              ANALYSIS RESULTS                               ║")
                    print("╚══════════════════════════════════════════════════════════════════════════════╝")
                    print("")
                    print("SUMMARY:")
                    print("  Duration: " .. string.format("%.2f", tick() - StartTime) .. "s")
                    print("  Risk Score: " .. riskScore.total_risk)
                    print("  Safety Score: " .. riskScore.safety_score .. "/100")
                    print("  Blocked Scripts: " .. riskScore.blocked_scripts)
                    print("  HTTP Requests Monitored: " .. riskScore.http_spy_requests)
                    print("")
                    print("DETECTIONS:")
                    print("  Robux Stealers: " .. riskScore.robux_stealer_activities)
                    print("  Data Stealers: " .. riskScore.data_stealer_activities)
                    print("  Keyloggers: " .. riskScore.keylogger_activities)
                    print("  Webhooks: " .. riskScore.webhook_activities)
                    print("")
                    
                    local verdict = ""
                    local verdictIcon = ""
                    
                    if riskScore.robux_stealer_activities > CONFIG.ROBUX_STEALER_THRESHOLD then
                        verdict = "ROBUX STEALER DETECTED"
                        verdictIcon = "🔴"
                    elseif riskScore.data_stealer_activities > 1 or riskScore.webhook_activities > 0 then
                        verdict = "DATA STEALER DETECTED"
                        verdictIcon = "🔴"
                    elseif riskScore.keylogger_activities > CONFIG.KEYLOGGER_THRESHOLD then
                        verdict = "KEYLOGGER DETECTED"
                        verdictIcon = "🔴"
                    elseif riskScore.safety_score >= 90 then
                        verdict = "SAFE"
                        verdictIcon = "✅"
                    elseif riskScore.safety_score >= 70 then
                        verdict = "LOW RISK"
                        verdictIcon = "🟢"
                    else
                        verdict = "MODERATE RISK"
                        verdictIcon = "⚠️"
                    end
                    
                    print("VERDICT: " .. verdictIcon .. " " .. verdict)
                    print("")
                    
                    if #HTTPSpyLog > 0 then
                        print("HTTP SPY - OUTGOING/INCOMING PAIRS:")
                        local requestPairs = {}
                        for _, req in pairs(HTTPSpyLog) do
                            if not requestPairs[req.id] then
                                requestPairs[req.id] = {}
                            end
                            table.insert(requestPairs[req.id], req)
                        end
                        
                        local count = 0
                        for id, pair in pairs(requestPairs) do
                            if count >= 5 then break end
                            count = count + 1
                            local outgoing = nil
                            local incoming = nil
                            for _, req in pairs(pair) do
                                if req.direction == "OUTGOING" then
                                    outgoing = req
                                elseif req.direction == "INCOMING" then
                                    incoming = req
                                end
                            end
                            
                            if outgoing then
                                local urlDisplay = outgoing.url
                                if #urlDisplay > 60 then
                                    urlDisplay = string.sub(urlDisplay, 1, 60) .. "..."
                                end
                                print(string.format("  [%d] OUT: %s -> %s [%db]", count, outgoing.method, urlDisplay, outgoing.request_size))
                                if incoming then
                                    print(string.format("      IN:  Response received [%db]", incoming.response_size))
                                end
                            end
                        end
                        print("")
                    end
                    
                    if #MaliciousActivities > 0 then
                        print("TOP DETECTIONS:")
                        local sortedActivities = SortMaliciousByRisk(MaliciousActivities)
                        for i = 1, math.min(10, #sortedActivities) do
                            local activity = sortedActivities[i]
                            print(string.format("  [%d] %s (severity: %d)",
                                i, activity.type, activity.severity))
                        end
                    end
                end
                
                SaveLogsToFile(riskScore)
                
                print("")
                print("Monitoring complete!")
                debugPrint("Analysis complete", "INFO")
            end, "Main monitoring loop")
        end)
    end, "Starting monitoring")
end

SafeCall(function()
    ScriptTester:StartMonitoring()
end, "Main script execution")
